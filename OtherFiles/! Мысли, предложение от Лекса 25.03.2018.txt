Аня.
Я с пояснениями к сделанному, к интерфейсам и авторазации и регистрацией.

1) Везде в get запросах в такое, если была ошибка:

{
    "error": true,
    "result": null
}

Если ошибки не было, то "result" - нужный объект:

{
    "error": false,
    "result": {
        
    }
}

Вроде везде так делал, для унификации.
В таблице везде прописывал только вариант успешного выполнения запроса.

2) Добавил авторизацию и регистрацию, а также возможность выхода из зарегестрированного режима.
Смотри. Ты должна передавать заголовок "deadpool-token", значение которого - токен полученный в результате авторизации.
Можно прекратить действие токена, передав его в интерфейс выхода из системы. ПРОБЛЕМА: можно передать чужой. Потом прогуглю, чтобы ничего передавать не надо было, а брать из заголовков нужное.
Регистрация - эквивалентна по сути добавлению детектива. Сделал пока доступную всем. (В перспективе, если мы добавим статусы - можем добавить статус "Ожидается регистрация", для которого доступна только регистрация; при этом регистрация вообще левым людям будет недоступна. Но это бредовый вариант)
Интерфейсы подобно расписал.

Пока авторизация совершенна ужасна - если логин+пароль верны, то генерится рандомная строка, заносится в HashMap и хранится там (в БД никуда не ложится). Т.е. перезагрузка приложения - все полученные токены сразу не валидны.
Есть мысль усовершенствовать. Читал, что шифруется специально логин+пароль+доп_данные_для_сохранности алгоритмом, чтобы потом можно было расшифровать. Тогда мне не надо хранить все выданные токены. При этом в качестве доп.данныхх можно ввести дату выдачи/прекращения_действия токена, которую смотреть при проверке токена. Но пока не сделаю, т.к. нет интернета с нужными алгоритмами.

Авторизацию и выход из системы проверил, всё работает. Всё, кроме авторизации и регистрации, недоступно без правильного заголовка "deadpool-token".
Регистрацию пока протестить не могу, т.к. нет последних правок Андрея, и добавление нового детектива банально не работает.

Ах да!
Ввёл у Detective список прав доступа. С ДАО пока никак не связано, для всех пользователей проставляется только право доступа "Detective".
Пока предлагаю это не трогать. А то мы ДАО никогда не разгребём.

3) Не помню формат у DateTime для json. Кажется, вместо пробела в примерах "2012-02-25 12:25:25" надо писать латинскую "T". Надо прогуглить/проэкспериментировать.
Это я про добавление/изменение, где этот формат есть. Ну и про парсинг того, что приходит

4) Обновил все интерфейсы (старые, новые изначально были нормальные). Надеюсь, нигде не ошибся, т.к. местами писал сам, где ДАО нет ещё.

---

Надеюсь, ничего не забыл.
Ах да! Пароль для детектива "bartimeyse" - "test", без кавычек, естественно.



---------

Андрей. Есть вопрос по добавлению детектива.
Я не видел ещё, как ты поправил, но в версии, что у меня, отдельным запросом добавляется человек, и если это ппрошло
успешно - добавляется детектив.
Представим такую ситуацию. Человек добавился, детектив - нет. Такое может быть? Может (логин попался не уникальный).
С 3-й попытки пользователь всё-таки ввёл уникальный логин.
Сколько дубликатов у нас будет в `man`? Как я понимаю, 3, из них только 3-я запись будет использоваться.
Я это к чему. Как я помню, можно одним запросом вставить оддновременно в 2 таблицы. Имхо, так было бы правильнее.
Намёк понят?
То же с обновлением. Часть обновило (самого детектива), часть (данные человека) - нет. Транзакционность запросов,
не слышали ли вы, сударь?

И ещё. Везде в ДАО для объектов не помешали бы проверки на null. Или мне в сервисах проверять? Но тогда в тестах null не подашь...
Опять же, надо подумать.

И ещё, Андрей. В твоём коде нахожу такое:

	public void setName(String name) {
		if (isNullOrEmpty(name))
            this.name = "NoName";
        else
            this.name = name;
    }

    public void setSurname(String surname) {
        if (surname.equals(""))
            this.surname = "NoSurname";
        else
            this.surname = surname;
    }

Почему в одном месте на null проверяется, а в другом - нет?
Андрей, вот не люблю разочаровываться в людях, но ты невольно заставляешь это делать...	

Андрей. Думаю, НЕ НАДО обновлять человека при обновлении участника преступления. У Ани, думаю, будут разные страницы редактирования. Да и я в интерфейсах я это не закладывал: эти значения НЕ инициализируются.

Добавил в IDAODetective метод getAllDetectives. Вернуть все записи из `man`, которые остались после join с таблицей
`detective`. Возвращать должно List<Man>.
Думаю, метод всё же для IDAODetective, а не IDAOMan.
Методы getDetectiveByLogin и existDetectiveWithLogin на трогай, сам добавил для авторизации, работают вроде правильно.
---------




//обсудить. Обновление детектива - обновлять данные только детектива, или ещё и человека вместе? Сейчас и человека обновляет.
//посмотреть, как узнать покрытие кода
//попросить у Кости пример тестов ДАО